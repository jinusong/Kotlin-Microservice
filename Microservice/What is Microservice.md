# 마이크로 서비스는 뭘까?

## 마이크로 서비스란?
* 모듈 방식으로, 세분화된 기능을 제공하는 느슨하게 결합된 서비스입니다.
* 마이크로서비스는 관심 사항을 물리적으로 분리해 독립적으로 설계, 개발, 테스트, 배포할 수 있습니다.
* 모듈화의 특성으로 인해 지속적인 배포와 배포의 이상적인 후보가 됩니다.

## SoA란?
* 마이크로서비스는 서비스 지향 아키텍처(SoA)에서 발전한 개념입니다.
* 애플리케이션 컴포넌트를 기반으로 만들어지며, 이 컴포넌트는 원격에서 액세스할 수 있는 개별 기능을 가지는 일련의 서비스들로 이뤄집니다.

* SoA에서 서비스는 다음 4가지 속성을 가집니다.
    * 논리적으로 특정 결과를 갖는 비즈니스 활동을 상징합니다.
    * 자기완비적입니다.
    * 서비스 사용자에게는 블랙박스입니다.
    * 다른 기본 서비스를 활용해 구성할 수 있습니다.

* 전형적인 n티어 아키텍처에서 어플리케이션은 3개의 레이어로 나뉩니다.
    * 프레젠테이션 레이어: 사용자를 위한 UI
    * 비즈니스 레이어: 비즈니스 기능을 위한 도메인 로직을 구현한 서비스
    * 데이터 레이어: 도메인 모델을 관리

* 이런 레이어의 구성은 아키텍처에 여러 가지 이점을 제공합니다.
    * 표준화된 서비스 계약: 컴포넌트와 쉽게 통합할 수 있게 합니다.
    * 재사용성: 서비스가 서로에게 책임을 위임할 수 있게 합니다.
    * 비즈니스 가치: 비즈니스 기능을 구현합니다.
    * 복잡성 은닉: 데이터베이스를 변경해야 하는 경우 클라이언트는 영향을 받지 않습니다.
    * 자율성: 각 레이어는 분리가 가능하며 원격에서 액세스할 수 있습니다.

## SoA와 마이크로서비스의 차이점
* 이 아키텍처에서 레이어는 논리적으로 완전히 분리돼 있어서 서로 묶이지 않습니다.

* 이런 독립성으로 인해 마이크로 서비스는 해당 전문 기술을 팀 내에 구축할 수 있고, 비즈니스 역량에서부터 도메인 로직을 제어하는 전문팀은 더 나은 가치를 제공할 수 있습니다.
* 각 마이크로 서비스를 구축하는 개발 언어, 플랫폼, 기술의 범위를 다양화할 수 있습니다. 완전히 독립적이기 때문에 특정 요구 사항을 쉽게 적응하는데 필요한 특정기술을 사용할 수 있습니다.
* 마이크로 서비스는 모듈 방식이므로 독립적으로 배포할 수 있고, 각 모듈의 출시 주기가 다를 수 있습니다. 비슷한 맥락으로 개별적으로 확장도 가능합니다.

* 일반적으로 마이크로서비스를 위한 인프라가 더 단순합니다. 그래서 마이크로 서비스팀 내에 데브옵스 문화가 일반적인 관행이 되고 제품의 유연성을 높일 수 있습니다.
* 마이크로 서비스를 만드는 팀은 작아서, 피자 두판을 나눠 먹을 수 있는 규모 정도가 가장 적합합니다. 팀을 작게 유지하면 이런 유형의 아키텍처가 주는 가치를 극대화하는 데 도움이 됩니다.

## 일체형에서 마이크로서비스로
* SoA가 마이크로서비스로 진화하게 된 가장 큰 이유는 일체형이 가지는 문제 때문입니다. 프레젠테이션과 비즈니스 로직이 결합되었는데 도메인 모델이 복잡해지고 많은 소프트웨어 패턴이 생겨났습니다.
* 관심사의 분리(SoC)는 소프트웨어를 고유 영역으로 분리해서 각 영역이 단 하나의 관심사만 처리하도록 하는 설계 원칙입니다. 소프트웨어만이 아니라 아키텍처도 분리해야 합니다.
* SoA 같은 것들이 이런 목적으로 설계됐는데, 복잡성을 블랙박스 뒤에 숨겨서 아키텍처를 모듈화하고 복잡성을 해결할 수 있게 합니다.

* 우리는 상세한 비즈니스 규칙을 기반으로 하거나 심층 스키마 등 메인프레임에 복잡한 데이터 저장소를 만들 수 있고, 쉽게 조정이 가능하도록 하는 프레임워크와 도구를 선책할 수 있습니다. 
* 여기서 강력한 엔터프라이즈 서비스 버스(ESB)가 필요합니다.

* ESB는 서비스의 조정, 매핑, 라우팅을 담당하는 소프트웨어 컴포넌트입니다.

* ESB의 전반적인 사상은 메시지 조정을 위한 강력한 컴포넌트릉 갖추는 것인데 복잡한 어플리케이션을 만들려면 대부분의 요소를 사용해 서비스를 설계하기 때문에 복잡한 관계가 만들어졌습니다.
* 최종적으로 ESB에서 비즈니스 규칙을 기반으로 요소들을 조합하여 서비스를 만듭니다. 

* 특정 서비스 또는 스키마의 테이블 하나를 변경하면 전체 애플리케이션에 연쇄 반응을 유발하고 상호 의존적이기 떄문에 개별확장이 쉽지 않습니다. 이 것은 일체형 애플리케이션을 만들었다는 의미입니다.

* 그렇다고 SoA를 한다는 것이 일체형 어플리케이션을 만든다는 것을 의미하는 것이 아니라 이 것을 통해 아키텍쳐 패턴이 발전하여 지금의 마이크로 서비스가 나온 것입니다.

## 마이크로서비스 원칙
* 마이크로 서비스를 설계할 때 일련의 원칙을 선택해야 합니다. 개별 원칙은 고유한 장점이 있습니다.

    * 비즈니스 역량 중심 모델: 마이크로 서비스를 미래의 자신을 포함한 모든 사람이 이해할 수 있게 만들며, 서비스가 비즈니스 역량의 단순한 추상화가 아니라 원래 비즈니스 역량이 매핑되도록 합니다.

    * 느슨한 결합: 상호작용이 필요한 것처럼 마이크로서비스도 홀로 존재하는 서비스는 없으며, 상호작용을 구현할 때 최대한 느슨하게 결합해야 합니다.

    * 단일 책임: 어플리케이션에서 제공하는 기능 중 단일한 부분에 대한 책임만 져야 하며, 그 책임은 마이크로서비스에 의해 완전히 캠슐화되어야 합니다.

    * 구현 은닉: 일반적으로 마이크로서비스는 구현 세부사항을 숨기는, 명확하고 이해하기 쉬운 인터페이스를 가집니다. 내부의 세부 사항을 공개하면 안되며 기술적 구현이나 이를 구현하는 비즈니스 규칙도 노출돼서는 안됩니다.

    * 격리: 마이크로서비스는 마이크로서비스를 서비스하는 시스템의 인프라와 논리적으로나 물리적으로 분리되어야 합니다. 무조건 자체이며 외부 서비스에 영향을 주지 않습니다.

    * 독립적인 배포 가능: 마이크로서비스는 독립적으로 배포가 가능해야 합니다. 지속적으로 배포 가능.

    * 실패를 위한 빌드: 마이크로서비스에 장애가 발생한다면 이 장애를 최대한 매끄럽게 처리하도록 설계해야 하며 복구 방안을 정의해야 합니다. 다음과 같은 것들이 있습니다.
        * 업스트림: 서비스를 사용하는 소비자에게 어떻게 오류를 알릴 것인지, 또는 알리지 않을 것인지에 대한 것이며, 항상 커플링에 유의해야 합니다.
        * 다운스트림: 우리가 사용하는 다른 서비스나 데이터 베이스 같은 시스템이 장애를 일으킬 때 어떻게 대응하느냐 하는 것입니다.
        * 로깅: 장애를 기록하는 방법에 관한 것으로 로그를 남기는 빈도와 정보의 양 그리고 액세스 방법을 고려해야 합니다.
        * 모니터링: 모니터링 시스템에 올바른 정보 없이 장애를 처리하는 것은 문제가 매우 심각한 상황이므로 어플리케이션의 어떤 요소가 의미 있는 정보인지 고려해야 합니다.
        * 경고: 무언가 잘못되고 있음을 알리는 신호로 모니터링에 대한 링크와 로깅에 대한 이해를 돕는 것이지만 잘 설계하려면 이상한 것을 경고하는 것만으로는 충분하지 않습니다.
        * 복구: 장애가 발생했을 때 어떻게 정상 상태로 되돌릴 것인지 설계하는 것입니다. 자동 복구 말고도 수동 복구도 고려해야 합니다.
        * 폴백: 외부 서비스를 사용하는 경우 외부 서비스의 장애 상황에 대비해 폴백 메커니즘을 사용할 수 있습니다.

    * 확장성: 마이크로 서비스는 독립적으로 확장 가능하도록 설계되어야 합니다. 처리할 수 있는 요청 수나 보유할 수 있는 레코드의 수를 늘려야 할 경우에 개별적으로 확장해야 합니다.

    * 자동화: 구축, 테스트에서부터 배치, 모니터링에 이르기까지 자동화를 염두에 두고 설계해야 합니다. 자동화 원칙으로 민첨성은 향상, 불팔요한 수동 작업은 방지하며 지속적인 통합과 전달은 설계되어야 합니다.

